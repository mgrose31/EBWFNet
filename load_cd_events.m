function cd_data = load_cd_events(filename, flipX, flipY,maxevents)
% cd_data = load_cd_events(filename, flipX=0, flipY=0)
%
% Loads data from files generated by the StreamLogger consumer for any type
% of event. This function only read (t,x,y,p) and discard other fields (if
% any) of events.
% timestamps are in uS
% cd_data is a structure containing the fields ts, x, y and p
%
% flipX, flipY allow to flip the image around the X and Y axes. If these values
% are non zero, the corresponding dimension will be flipped considering its size
% to be the value contained in the 'flip' variable (i.e. X = flipX - X)
% (They defaults to 0 if non-specified)

if ~exist('flipX','var')
    flipX = 0;
end
if ~exist('flipY','var')
    flipY = 0;
end
if ~exist('maxevents','var')
    maxevents=inf;
end
f=fopen(filename);

% Parse header if any
header = [];
endOfHeader = 0;
numCommentLine = 0;
k = 1;
while (endOfHeader==0 & k<=4)
    bod = ftell(f);
    tline = fgets(f,256);
    if(tline(1)~='%')
        endOfHeader = 1;
    else
        words = strsplit(tline);
        if (length(words) > 2 )
            if (strcmp(words{2} , 'Date'))
                if (length(words) > 3)
                    header = [header; {words{2}, horzcat(words{3}, ' ', words{4})}];
                end
            else
                header = [header; {words{2}, words{3}}];
            end
        end
        numCommentLine = numCommentLine+1;
    end
k=k+1;    
end
%fseek(f,bod,'bof');

evType = 0;
evSize = 8;
if (numCommentLine>0) % Ensure compatibility with previous files.
    % Read event type
    evType = fread(f,1,'char');
    % Read event size
    evSize = fread(f,1,'char');
end


bof=ftell(f);

fseek(f,0,'eof');
numEvents=min(floor((ftell(f)-bof)/evSize),maxevents);

% read data
fseek(f,bof,'bof'); % start just after header
allTs=uint32(fread(f,numEvents,'uint32',evSize-4,'l')); % ts are 4 bytes (uint32) skipping 4 bytes after each
fseek(f,bof+4,'bof'); % timestamps start 4 after bof
allAddr=uint32(fread(f,numEvents,'uint32',evSize-4,'l')); % addr are each 4 bytes (uint32) separated by 4 byte timestamps

fclose(f);

cd_data.ts = double(allTs);

version = 0;
index = find(strcmp(header(:,1), 'Version'));
if (~isempty(index))
    version = header{index, 2};
end

if (version < 2)
    xmask = hex2dec('000001FF');
    ymask = hex2dec('0001FE00');
    polmask = hex2dec('00020000');
    xshift=0; % bits to shift x to right
    yshift=9; % bits to shift y to right
    polshift=17; % bits to shift p to right
else
    xmask = hex2dec('00003FFF');
    ymask = hex2dec('0FFFC000');
    polmask = hex2dec('10000000');
    xshift=0; % bits to shift x to right
    yshift=14; % bits to shift y to right
    polshift=28; % bits to shift p to right
end

addr=abs(allAddr); % make sure non-negative or an error will result from bitand (glitches can somehow result in negative addressses...)
cd_data.x=double(bitshift(bitand(addr,xmask),-xshift)); % x addresses
cd_data.y=double(bitshift(bitand(addr,ymask),-yshift)); % y addresses
cd_data.p=-1+2*double(bitshift(bitand(addr,polmask),-polshift)); % 1 for ON, -1 for OFF

if (flipX > 0)
    cd_data.x = flipX - cd_data.x;
end

if (flipY > 0)
    cd_data.y = flipY - cd_data.y;
end

end
